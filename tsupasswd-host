#!/usr/bin/env python3
import sys, json, struct, subprocess, os, shutil

def _find_in_obj(obj, keys_lower):
    """Recursively find first matching key's string-like value in nested dict/list JSON.
    Also supports key-value field shapes like {k/key/name: <fieldName>, v/value: <fieldValue>}.
    """
    if isinstance(obj, dict):
        # Prefer direct match on this level
        for k, v in obj.items():
            if isinstance(k, str) and k.lower() in keys_lower:
                if isinstance(v, (str, int, float)):
                    return str(v)
        # Support key-value style field objects
        kv_name_keys = ("k", "key", "name", "field", "label")
        kv_value_keys = ("v", "value", "val", "content")
        name_val = None
        for nk in kv_name_keys:
            if nk in obj and isinstance(obj[nk], str) and obj[nk].lower() in keys_lower:
                name_val = obj[nk]
                break
        if name_val is not None:
            for vk in kv_value_keys:
                if vk in obj and isinstance(obj[vk], (str, int, float)):
                    return str(obj[vk])
        # Recurse into values
        for v in obj.values():
            found = _find_in_obj(v, keys_lower)
            if found is not None:
                return found
    elif isinstance(obj, list):
        for item in obj:
            found = _find_in_obj(item, keys_lower)
            if found is not None:
                return found
    return None

def read_msg():
    raw_len = sys.stdin.buffer.read(4)
    if len(raw_len) == 0:
        return None
    msg_len = struct.unpack('<I', raw_len)[0]
    data = sys.stdin.buffer.read(msg_len)
    return json.loads(data.decode('utf-8'))

def write_msg(msg):
    raw = json.dumps(msg).encode('utf-8')
    sys.stdout.buffer.write(struct.pack('<I', len(raw)))
    sys.stdout.buffer.write(raw)
    sys.stdout.flush()

while True:
    msg = read_msg()
    if msg is None:
        break
    try:
        # 実行ファイルの探索（環境依存対策）
        def find_bin():
            cand = []
            # メッセージからの明示指定を最優先
            try:
                m_bin = None
                if isinstance(msg, dict):
                    m_bin = msg.get('bin') or msg.get('binPath')
                if m_bin:
                    cand.append(str(m_bin))
            except Exception:
                pass
            # 環境変数（ネイティブホストのプロセス環境）
            env = os.environ.get('TSUPASSWD_BIN')
            if env:
                cand.append(env)
            # PATH からの探索
            which = shutil.which('tsupasswd')
            if which:
                cand.append(which)
            # よくある場所
            common = [
                '/usr/local/bin/tsupasswd',
                '/usr/bin/tsupasswd',
                '/opt/homebrew/bin/tsupasswd',
                'C:\\Users\\f-tsu\\AppData\\Local\\tsupasswd\\tsupasswd.exe',
            ]
            cand.extend(common)
            for p in cand:
                try:
                    if p and os.path.isfile(p) and os.access(p, os.X_OK):
                        return p
                except Exception:
                    pass
            # 最後の手段として環境変数のみ返す
            return None

        # 実行時環境を組み立て（AUTH_SECRETなどを渡す）。メッセージのsecretが優先
        def build_run_env(secret=None):
            env = os.environ.copy()
            auth_secret = secret if (secret is not None and secret != '') else os.environ.get('AUTH_SECRET')
            if auth_secret is not None:
                env['AUTH_SECRET'] = auth_secret
            return env

        action = msg.get('action')
        if action == 'SAVE':
            # 保存リクエスト: { action: 'SAVE', entry: { title, url, username, password, note } }
            entry = msg.get('entry') or {}
            secret = msg.get('secret') or ''
            title = str(entry.get('title') or '')
            url = str(entry.get('url') or '')
            username = str(entry.get('username') or '')
            password = str(entry.get('password') or '')
            note = str(entry.get('note') or '')
            bin_path = find_bin()
            if not bin_path:
                write_msg({"ok": False, "error": "tsupasswd binary not found or not executable. Set TSUPASSWD_BIN or install 'tsupasswd' in PATH."})
                last_err = None
                continue

        elif action == 'DELETE':
            # 削除リクエスト: { action: 'DELETE', entry: { id } }
            entry = msg.get('entry') or {}
            secret = msg.get('secret') or ''
            rid = str(entry.get('id') or '')
            bin_path = find_bin()
            if not bin_path:
                write_msg({"ok": False, "error": "tsupasswd binary not found or not executable. Set TSUPASSWD_BIN or install 'tsupasswd' in PATH."})
                continue
            # 必須: id
            if not rid:
                write_msg({"ok": False, "error": "missing required fields (id)", "cmd": ["delete", rid or '']})
                continue
            cmd = [bin_path, 'delete', rid]
            try:
                cp = subprocess.run(cmd, capture_output=True, text=True, env=build_run_env(secret), timeout=12)
                if cp.returncode == 0:
                    write_msg({"ok": True, "stdout": (cp.stdout or '').strip(), "cmd": cmd})
                else:
                    write_msg({"ok": False, "error": (((cp.stderr or '').strip()) or ((cp.stdout or '').strip()) or "tsupasswd delete failed"), "stdout": (cp.stdout or '').strip(), "stderr": (cp.stderr or '').strip(), "cmd": cmd})
            except subprocess.TimeoutExpired:
                write_msg({"ok": False, "error": "tsupasswd delete timeout", "cmd": cmd})
            continue
            # 位置引数: URL ユーザID パスワード（空なら空文字）/ オプション: --title タイトル, --note 備考
            def build_args():
                if not url:
                    return None
                usr = username if username is not None else ''
                pwd = password if password is not None else ''
                args = [bin_path, 'add', url, usr, pwd]
                if title:
                    args.extend(['--title', title])
                if note:
                    args.extend(['--note', note])
                return args
            cmd = build_args()
            if not cmd:
                write_msg({"ok": False, "error": "missing required fields (url)", "cmd": ["add", url or '', (username or ''), "***"]})
            else:
                try:
                    cp = subprocess.run(cmd, capture_output=True, text=True, env=build_run_env(secret), timeout=20)
                    if cp.returncode == 0:
                        write_msg({"ok": True, "stdout": (cp.stdout or '').strip(), "cmd": cmd})
                    else:
                        write_msg({"ok": False, "error": (((cp.stderr or '').strip()) or ((cp.stdout or '').strip()) or "tsupasswd save failed"), "stdout": (cp.stdout or '').strip(), "stderr": (cp.stderr or '').strip(), "cmd": cmd})
                except subprocess.TimeoutExpired as te:
                    write_msg({"ok": False, "error": "tsupasswd save timeout", "cmd": cmd})
            last_err = None
            # 既存のループは不要になったため削除
            continue

        elif action == 'AUTH':
            # 認証: { action: 'AUTH', mode?: 'secret' }
            # 例: tsupasswd auth secret （AUTH_SECRETはenvで渡す）
            mode = str(msg.get('mode') or 'secret')
            secret = msg.get('secret') or ''
            bin_path = find_bin()
            if not bin_path:
                write_msg({"ok": False, "error": "tsupasswd binary not found or not executable. Set TSUPASSWD_BIN or install 'tsupasswd' in PATH."})
                continue
            cmd = [bin_path, 'auth', mode]
            try:
                cp = subprocess.run(cmd, capture_output=True, text=True, env=build_run_env(secret), timeout=20)
                if cp.returncode == 0:
                    write_msg({"ok": True, "stdout": (cp.stdout or '').strip(), "cmd": cmd})
                else:
                    write_msg({"ok": False, "error": (((cp.stderr or '').strip()) or ((cp.stdout or '').strip()) or "tsupasswd auth failed"), "stdout": (cp.stdout or '').strip(), "stderr": (cp.stderr or '').strip(), "cmd": cmd})
            except subprocess.TimeoutExpired:
                write_msg({"ok": False, "error": "tsupasswd auth timeout", "cmd": cmd})
            continue

        # 既存: 検索（資格情報取得）/ 認証（auth）/ 保存（add）
        args = msg.get('args') or []
        secret = msg.get('secret') or ''
        bin_path = find_bin()
        if not bin_path:
            write_msg({"ok": False, "error": "tsupasswd binary not found or not executable. Set TSUPASSWD_BIN or install 'tsupasswd' in PATH."})
            continue
        a0 = str(args[0]) if args else ''
        if a0 == 'add':
            # 保存
            cmd = [bin_path] + args
            try:
                cp = subprocess.run(cmd, capture_output=True, text=True, env=build_run_env(secret), timeout=8)
                if cp.returncode != 0:
                    write_msg({"ok": False, "error": (((cp.stderr or '').strip()) or ((cp.stdout or '').strip()) or "tsupasswd failed"), "stdout": (cp.stdout or '').strip(), "stderr": (cp.stderr or '').strip(), "cmd": cmd})
                else:
                    write_msg({"ok": True, "stdout": (cp.stdout or '').strip(), "cmd": cmd})
            except subprocess.TimeoutExpired:
                write_msg({"ok": False, "error": "tsupasswd add timeout", "cmd": cmd})
        elif a0 == 'auth':
            # 認証: tsupasswd auth <secret or mode>
            cmd = [bin_path, 'auth'] + list(args[1:])
            try:
                cp = subprocess.run(cmd, capture_output=True, text=True, env=build_run_env(secret), timeout=20)
                if cp.returncode == 0:
                    write_msg({"ok": True, "stdout": (cp.stdout or '').strip(), "cmd": cmd})
                else:
                    write_msg({"ok": False, "error": (((cp.stderr or '').strip()) or ((cp.stdout or '').strip()) or "tsupasswd auth failed"), "stdout": (cp.stdout or '').strip(), "stderr": (cp.stderr or '').strip(), "cmd": cmd})
            except subprocess.TimeoutExpired:
                write_msg({"ok": False, "error": "tsupasswd auth timeout", "cmd": cmd})
        elif a0 == 'update':
            # 更新: tsupasswd update <id> [--url U] [--user NAME] [--password PASS | --length N] [--title T] [--note N]
            # 一部実装では 'update' が存在しない可能性があるため 'set' や 'edit' にフォールバック
            attempts = []
            subcmds = ['update', 'set', 'edit']
            last_err = None
            for sub in subcmds:
                try:
                    cmd = [bin_path, sub] + list(args[1:])
                    cp = subprocess.run(cmd, capture_output=True, text=True, env=build_run_env(secret), timeout=12)
                    if cp.returncode == 0:
                        write_msg({"ok": True, "stdout": (cp.stdout or '').strip(), "cmd": cmd})
                        last_err = None
                        break
                    else:
                        attempts.append({"subcmd": sub, "stderr": (cp.stderr or '').strip(), "stdout": (cp.stdout or '').strip(), "code": cp.returncode})
                        last_err = ((cp.stderr or '').strip()) or ((cp.stdout or '').strip()) or f"tsupasswd {sub} failed"
                except subprocess.TimeoutExpired:
                    attempts.append({"subcmd": sub, "stderr": "timeout"})
                    last_err = f"tsupasswd {sub} timeout"
            if last_err is not None:
                write_msg({"ok": False, "error": last_err, "attempts": attempts})
        else:
            # 検索
            cmd = [bin_path, "search"] + (args or []) + ["--json"]
            try:
                cp = subprocess.run(cmd, capture_output=True, text=True, env=build_run_env(secret), timeout=8)
                if cp.returncode != 0:
                    write_msg({"ok": False, "error": ((cp.stderr or '').strip() or "tsupasswd failed")})
                else:
                    out = (cp.stdout or '').strip()
                    # 可能なら JSON として読み取り、複数件も整形
                    try:
                        data = json.loads(out)
                        user_keys = {"username", "user", "login", "account", "email"}
                        pass_keys = {"password", "pass", "secret"}
                        title_keys = {"title", "name", "label"}
                        url_keys = {"url", "uri", "link"}
                        note_keys = {"note", "memo", "remark", "comment"}
                        id_keys = {"id", "entry_id", "credential_id"}

                        entries = []
                        # 結果がリスト、もしくはオブジェクト内の配列フィールドを探索
                        cand_list = None
                        if isinstance(data, list):
                            cand_list = data
                        elif isinstance(data, dict):
                            # 最上位の配列フィールドを一つ拾う（簡易）
                            for v in data.values():
                                if isinstance(v, list):
                                    cand_list = v
                                    break
                        if cand_list is None:
                            cand_list = [data]

                        for item in cand_list:
                            try:
                                e = {
                                    "id": _find_in_obj(item, id_keys) or "",
                                    "title": _find_in_obj(item, title_keys) or "",
                                    "url": _find_in_obj(item, url_keys) or "",
                                    "username": _find_in_obj(item, user_keys) or "",
                                    "password": _find_in_obj(item, pass_keys) or "",
                                    "note": _find_in_obj(item, note_keys) or "",
                                }
                                if any([e["username"], e["password"], e["title"], e["url"], e["note"]]):
                                    entries.append(e)
                            except Exception:
                                pass

                        # 後方互換のため、先頭要素のusername/passwordも併記
                        first_user = entries[0]["username"] if entries else (_find_in_obj(data, user_keys) or "")
                        first_pass = entries[0]["password"] if entries else (_find_in_obj(data, pass_keys) or "")
                        write_msg({"ok": True, "entries": entries, "username": first_user, "password": first_pass})
                    except Exception:
                        # 非JSON出力の場合のフォールバック（簡易抽出）
                        import re
                        m_user = re.search(r"user(?:name)?[:=]\s*(\S+)", out, re.IGNORECASE)
                        m_pass = re.search(r"pass(?:word)?[:=]\s*(\S+)", out, re.IGNORECASE)
                        username = m_user.group(1) if m_user else ""
                        password = m_pass.group(1) if m_pass else ""
                        write_msg({"ok": True, "entries": [{"title": "", "url": "", "username": username, "password": password, "note": ""}], "username": username, "password": password})
            except subprocess.TimeoutExpired:
                write_msg({"ok": False, "error": "tsupasswd search timeout", "cmd": cmd})
                # 可能なら JSON として読み取り、複数件も整形
                try:
                    data = json.loads(out)
                    user_keys = {"username", "user", "login", "account", "email"}
                    pass_keys = {"password", "pass", "secret"}
                    title_keys = {"title", "name", "label"}
                    url_keys = {"url", "uri", "link"}
                    note_keys = {"note", "memo", "remark", "comment"}

                    entries = []
                    # 結果がリスト、もしくはオブジェクト内の配列フィールドを探索
                    cand_list = None
                    if isinstance(data, list):
                        cand_list = data
                    elif isinstance(data, dict):
                        # 最上位の配列フィールドを一つ拾う（簡易）
                        for v in data.values():
                            if isinstance(v, list):
                                cand_list = v
                                break
                    if cand_list is None:
                        cand_list = [data]

                    for item in cand_list:
                        try:
                            e = {
                                "title": _find_in_obj(item, title_keys) or "",
                                "url": _find_in_obj(item, url_keys) or "",
                                "username": _find_in_obj(item, user_keys) or "",
                                "password": _find_in_obj(item, pass_keys) or "",
                                "note": _find_in_obj(item, note_keys) or "",
                            }
                            if any([e["username"], e["password"], e["title"], e["url"], e["note"]]):
                                entries.append(e)
                        except Exception:
                            pass

                    # 後方互換のため、先頭要素のusername/passwordも併記
                    first_user = entries[0]["username"] if entries else (_find_in_obj(data, user_keys) or "")
                    first_pass = entries[0]["password"] if entries else (_find_in_obj(data, pass_keys) or "")
                    write_msg({"ok": True, "entries": entries, "username": first_user, "password": first_pass})
                except Exception:
                    # 非JSON出力の場合のフォールバック（簡易抽出）
                    # 例: "user: alice\npass: secret" や "username=alice password=secret"
                    import re
                    m_user = re.search(r"user(?:name)?[:=]\s*(\S+)", out, re.IGNORECASE)
                    m_pass = re.search(r"pass(?:word)?[:=]\s*(\S+)", out, re.IGNORECASE)
                    username = m_user.group(1) if m_user else ""
                    password = m_pass.group(1) if m_pass else ""
                    write_msg({"ok": True, "entries": [{"title": "", "url": "", "username": username, "password": password, "note": ""}], "username": username, "password": password})
    except Exception as e:
        write_msg({"ok": False, "error": str(e)})
