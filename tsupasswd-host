#!/usr/bin/env python3
import sys, json, struct, subprocess

def _find_in_obj(obj, keys_lower):
    """Recursively find first matching key's string-like value in nested dict/list JSON.
    Also supports key-value field shapes like {k/key/name: <fieldName>, v/value: <fieldValue>}.
    """
    if isinstance(obj, dict):
        # Prefer direct match on this level
        for k, v in obj.items():
            if isinstance(k, str) and k.lower() in keys_lower:
                if isinstance(v, (str, int, float)):
                    return str(v)
        # Support key-value style field objects
        kv_name_keys = ("k", "key", "name", "field", "label")
        kv_value_keys = ("v", "value", "val", "content")
        name_val = None
        for nk in kv_name_keys:
            if nk in obj and isinstance(obj[nk], str) and obj[nk].lower() in keys_lower:
                name_val = obj[nk]
                break
        if name_val is not None:
            for vk in kv_value_keys:
                if vk in obj and isinstance(obj[vk], (str, int, float)):
                    return str(obj[vk])
        # Recurse into values
        for v in obj.values():
            found = _find_in_obj(v, keys_lower)
            if found is not None:
                return found
    elif isinstance(obj, list):
        for item in obj:
            found = _find_in_obj(item, keys_lower)
            if found is not None:
                return found
    return None

def read_msg():
    raw_len = sys.stdin.buffer.read(4)
    if len(raw_len) == 0:
        return None
    msg_len = struct.unpack('<I', raw_len)[0]
    data = sys.stdin.buffer.read(msg_len)
    return json.loads(data.decode('utf-8'))

def write_msg(msg):
    raw = json.dumps(msg).encode('utf-8')
    sys.stdout.buffer.write(struct.pack('<I', len(raw)))
    sys.stdout.buffer.write(raw)
    sys.stdout.flush()

while True:
    msg = read_msg()
    if msg is None:
        break
    args = msg.get('args') or []
    try:
        # tsupasswd を JSON 出力で実行（--json をホスト側で付与）
        # コマンドはトークン単位で分割して渡す
        cmd = [
            "/Users/tsu/src/rust/password/target/debug/tsupasswd",
            "search",
        ] + (args or []) + ["--json"]
        cp = subprocess.run(cmd, capture_output=True, text=True)
        if cp.returncode != 0:
            write_msg({"ok": False, "error": (cp.stderr.strip() or "tsupasswd failed")})
        else:
            out = cp.stdout.strip()
            # 可能なら JSON として読み取り、username/password を整形
            try:
                data = json.loads(out)
                user_keys = {"username", "user", "login", "account", "email"}
                pass_keys = {"password", "pass", "secret"}
                username = _find_in_obj(data, user_keys) or ""
                password = _find_in_obj(data, pass_keys) or ""
                write_msg({"ok": True, "username": username, "password": password})
            except Exception:
                # 非JSON出力の場合のフォールバック（簡易抽出）
                # 例: "user: alice\npass: secret" や "username=alice password=secret"
                import re
                m_user = re.search(r"user(?:name)?[:=]\s*(\S+)", out, re.IGNORECASE)
                m_pass = re.search(r"pass(?:word)?[:=]\s*(\S+)", out, re.IGNORECASE)
                username = m_user.group(1) if m_user else ""
                password = m_pass.group(1) if m_pass else ""
                write_msg({"ok": True, "username": username, "password": password})
    except Exception as e:
        write_msg({"ok": False, "error": str(e)})
